"""
Base class for trading signal generators.
All strategies inherit from this abstract class.
"""

from abc import ABC, abstractmethod
from dataclasses import dataclass
from datetime import datetime
from enum import IntEnum
from typing import Optional, List, Dict, Any, Tuple
import pandas as pd
import numpy as np


class SignalDirection(IntEnum):
    """Signal direction enumeration."""
    SHORT = -1
    NEUTRAL = 0
    LONG = 1


@dataclass
class Signal:
    """
    Represents a trading signal generated by a strategy.

    Attributes:
        timestamp: When the signal was generated
        symbol: Trading pair symbol
        direction: Signal direction (-1, 0, 1)
        confidence: Signal confidence (0-1)
        entry_price: Suggested entry price
        stop_loss: Suggested stop loss price
        take_profit: Suggested take profit price
        metadata: Additional strategy-specific data
    """
    timestamp: datetime
    symbol: str
    direction: SignalDirection
    confidence: float = 1.0
    entry_price: Optional[float] = None
    stop_loss: Optional[float] = None
    take_profit: Optional[float] = None
    metadata: Optional[Dict[str, Any]] = None

    def to_dict(self) -> Dict[str, Any]:
        """Convert signal to dictionary."""
        return {
            "timestamp": self.timestamp.isoformat() if isinstance(self.timestamp, datetime) else self.timestamp,
            "symbol": self.symbol,
            "direction": int(self.direction),
            "confidence": self.confidence,
            "entry_price": self.entry_price,
            "stop_loss": self.stop_loss,
            "take_profit": self.take_profit,
            "metadata": self.metadata
        }


class SignalGenerator(ABC):
    """
    Abstract base class for trading signal generators.

    All strategy implementations must inherit from this class
    and implement the required methods.
    """

    def __init__(self, name: str, **params):
        """
        Initialize signal generator.

        Args:
            name: Strategy name
            **params: Strategy-specific parameters
        """
        self.name = name
        self.params = params

    @abstractmethod
    def generate_signals(
        self,
        df: pd.DataFrame,
        symbol: str
    ) -> List[Signal]:
        """
        Generate trading signals from OHLCV data.

        Args:
            df: DataFrame with OHLCV data (must have timestamp, open, high, low, close, volume)
            symbol: Trading pair symbol

        Returns:
            List of Signal objects
        """
        pass

    @abstractmethod
    def compute_indicators(self, df: pd.DataFrame) -> pd.DataFrame:
        """
        Compute indicators needed by this strategy.

        Args:
            df: DataFrame with OHLCV data

        Returns:
            DataFrame with added indicator columns
        """
        pass

    def get_signal_column(self) -> str:
        """Get the column name for this strategy's signals."""
        return f"signal_{self.name}"

    def get_confidence_column(self) -> str:
        """Get the column name for this strategy's confidence."""
        return f"conf_{self.name}"

    def add_signals_to_df(
        self,
        df: pd.DataFrame,
        symbol: str
    ) -> pd.DataFrame:
        """
        Add signal columns to DataFrame.

        Args:
            df: DataFrame with OHLCV data
            symbol: Trading pair symbol

        Returns:
            DataFrame with signal columns added
        """
        # Generate signals
        signals = self.generate_signals(df, symbol)

        # Create signal lookup by timestamp
        signal_map = {s.timestamp: s for s in signals}

        # Initialize columns
        signal_col = self.get_signal_column()
        conf_col = self.get_confidence_column()

        df[signal_col] = 0
        df[conf_col] = np.nan

        # Fill in signals
        for idx, row in df.iterrows():
            ts = row["timestamp"]
            if ts in signal_map:
                signal = signal_map[ts]
                df.at[idx, signal_col] = int(signal.direction)
                df.at[idx, conf_col] = signal.confidence

        return df

    def backtest_signals(
        self,
        df: pd.DataFrame,
        signals: List[Signal],
        holding_bars: int = 10,
        fee_rate: float = 0.001
    ) -> List[Dict[str, Any]]:
        """
        Simple backtest of signals to compute outcomes.

        Args:
            df: DataFrame with OHLCV data
            signals: List of signals to evaluate
            holding_bars: Number of bars to hold position
            fee_rate: Trading fee rate (one-way)

        Returns:
            List of trade outcome dictionaries
        """
        outcomes = []

        # Create timestamp to index mapping
        df = df.reset_index(drop=True)
        ts_to_idx = {row["timestamp"]: idx for idx, row in df.iterrows()}

        for signal in signals:
            if signal.direction == SignalDirection.NEUTRAL:
                continue

            entry_idx = ts_to_idx.get(signal.timestamp)
            if entry_idx is None:
                continue

            exit_idx = min(entry_idx + holding_bars, len(df) - 1)

            entry_price = signal.entry_price or df.at[entry_idx, "close"]
            exit_price = df.at[exit_idx, "close"]

            # Calculate PnL
            if signal.direction == SignalDirection.LONG:
                pnl = (exit_price - entry_price) / entry_price
            else:  # SHORT
                pnl = (entry_price - exit_price) / entry_price

            # Subtract fees
            pnl -= 2 * fee_rate  # Entry and exit

            outcome = "WIN" if pnl > 0 else "LOSS"

            outcomes.append({
                "timestamp": signal.timestamp,
                "symbol": signal.symbol,
                "direction": int(signal.direction),
                "entry_price": entry_price,
                "exit_price": exit_price,
                "pnl_percent": pnl * 100,
                "outcome": outcome,
                "bars_held": exit_idx - entry_idx
            })

        return outcomes

    def __repr__(self) -> str:
        return f"{self.__class__.__name__}(name='{self.name}', params={self.params})"


# -------------------------------------------------------------------------
# Indicator Helper Functions
# -------------------------------------------------------------------------

def ema(series: pd.Series, period: int) -> pd.Series:
    """Calculate Exponential Moving Average."""
    return series.ewm(span=period, adjust=False).mean()


def sma(series: pd.Series, period: int) -> pd.Series:
    """Calculate Simple Moving Average."""
    return series.rolling(window=period).mean()


def rsi(series: pd.Series, period: int = 14) -> pd.Series:
    """Calculate Relative Strength Index."""
    delta = series.diff()
    gain = delta.where(delta > 0, 0)
    loss = -delta.where(delta < 0, 0)

    avg_gain = gain.ewm(com=period - 1, min_periods=period).mean()
    avg_loss = loss.ewm(com=period - 1, min_periods=period).mean()

    rs = avg_gain / avg_loss
    return 100 - (100 / (1 + rs))


def macd(
    series: pd.Series,
    fast: int = 12,
    slow: int = 26,
    signal: int = 9
) -> Tuple[pd.Series, pd.Series, pd.Series]:
    """
    Calculate MACD.

    Returns:
        Tuple of (macd_line, signal_line, histogram)
    """
    fast_ema = ema(series, fast)
    slow_ema = ema(series, slow)
    macd_line = fast_ema - slow_ema
    signal_line = ema(macd_line, signal)
    histogram = macd_line - signal_line

    return macd_line, signal_line, histogram


def stochastic(
    high: pd.Series,
    low: pd.Series,
    close: pd.Series,
    k_period: int = 14,
    d_period: int = 3
) -> Tuple[pd.Series, pd.Series]:
    """
    Calculate Stochastic Oscillator.

    Returns:
        Tuple of (%K, %D)
    """
    lowest_low = low.rolling(window=k_period).min()
    highest_high = high.rolling(window=k_period).max()

    k = 100 * (close - lowest_low) / (highest_high - lowest_low)
    d = k.rolling(window=d_period).mean()

    return k, d


def atr(
    high: pd.Series,
    low: pd.Series,
    close: pd.Series,
    period: int = 14
) -> pd.Series:
    """Calculate Average True Range."""
    tr1 = high - low
    tr2 = abs(high - close.shift(1))
    tr3 = abs(low - close.shift(1))

    tr = pd.concat([tr1, tr2, tr3], axis=1).max(axis=1)
    return tr.rolling(window=period).mean()


def bollinger_bands(
    series: pd.Series,
    period: int = 20,
    std_mult: float = 2.0
) -> Tuple[pd.Series, pd.Series, pd.Series]:
    """
    Calculate Bollinger Bands.

    Returns:
        Tuple of (upper, middle, lower)
    """
    middle = sma(series, period)
    std = series.rolling(window=period).std()
    upper = middle + std_mult * std
    lower = middle - std_mult * std

    return upper, middle, lower


def donchian_channel(
    high: pd.Series,
    low: pd.Series,
    period: int = 20
) -> Tuple[pd.Series, pd.Series]:
    """
    Calculate Donchian Channel.

    Returns:
        Tuple of (upper, lower)
    """
    upper = high.rolling(window=period).max()
    lower = low.rolling(window=period).min()

    return upper, lower


def pivot_high(high: pd.Series, lookback: int = 5) -> pd.Series:
    """
    Detect pivot highs.

    Returns:
        Series with pivot high prices (NaN where not pivot)
    """
    result = pd.Series(index=high.index, dtype=float)
    result[:] = np.nan

    for i in range(lookback, len(high) - lookback):
        window = high.iloc[i - lookback:i + lookback + 1]
        if high.iloc[i] == window.max():
            result.iloc[i] = high.iloc[i]

    return result


def pivot_low(low: pd.Series, lookback: int = 5) -> pd.Series:
    """
    Detect pivot lows.

    Returns:
        Series with pivot low prices (NaN where not pivot)
    """
    result = pd.Series(index=low.index, dtype=float)
    result[:] = np.nan

    for i in range(lookback, len(low) - lookback):
        window = low.iloc[i - lookback:i + lookback + 1]
        if low.iloc[i] == window.min():
            result.iloc[i] = low.iloc[i]

    return result


def adx(
    high: pd.Series,
    low: pd.Series,
    close: pd.Series,
    period: int = 14
) -> Tuple[pd.Series, pd.Series, pd.Series]:
    """
    Calculate Average Directional Index.

    Returns:
        Tuple of (ADX, +DI, -DI)
    """
    # True Range
    tr1 = high - low
    tr2 = abs(high - close.shift(1))
    tr3 = abs(low - close.shift(1))
    tr = pd.concat([tr1, tr2, tr3], axis=1).max(axis=1)

    # Directional Movement
    up_move = high - high.shift(1)
    down_move = low.shift(1) - low

    plus_dm = np.where((up_move > down_move) & (up_move > 0), up_move, 0)
    minus_dm = np.where((down_move > up_move) & (down_move > 0), down_move, 0)

    # Smoothed values
    tr_smooth = pd.Series(tr).rolling(window=period).sum()
    plus_dm_smooth = pd.Series(plus_dm).rolling(window=period).sum()
    minus_dm_smooth = pd.Series(minus_dm).rolling(window=period).sum()

    # DI values
    plus_di = 100 * plus_dm_smooth / tr_smooth
    minus_di = 100 * minus_dm_smooth / tr_smooth

    # DX and ADX
    dx = 100 * abs(plus_di - minus_di) / (plus_di + minus_di)
    adx_val = dx.rolling(window=period).mean()

    return adx_val, plus_di, minus_di


def cci(
    high: pd.Series,
    low: pd.Series,
    close: pd.Series,
    period: int = 20
) -> pd.Series:
    """Calculate Commodity Channel Index."""
    typical_price = (high + low + close) / 3
    sma_tp = typical_price.rolling(window=period).mean()
    mean_dev = typical_price.rolling(window=period).apply(
        lambda x: np.abs(x - x.mean()).mean()
    )
    return (typical_price - sma_tp) / (0.015 * mean_dev)


def mfi(
    high: pd.Series,
    low: pd.Series,
    close: pd.Series,
    volume: pd.Series,
    period: int = 14
) -> pd.Series:
    """Calculate Money Flow Index."""
    typical_price = (high + low + close) / 3
    raw_money_flow = typical_price * volume

    positive_flow = np.where(
        typical_price > typical_price.shift(1),
        raw_money_flow, 0
    )
    negative_flow = np.where(
        typical_price < typical_price.shift(1),
        raw_money_flow, 0
    )

    positive_mf = pd.Series(positive_flow).rolling(window=period).sum()
    negative_mf = pd.Series(negative_flow).rolling(window=period).sum()

    mfi_ratio = positive_mf / negative_mf
    return 100 - (100 / (1 + mfi_ratio))


def obv(close: pd.Series, volume: pd.Series) -> pd.Series:
    """Calculate On-Balance Volume."""
    direction = np.sign(close.diff())
    direction.iloc[0] = 0
    return (volume * direction).cumsum()
